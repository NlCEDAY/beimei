## Python--numpy库常用方法：

### 1.显式转换数组的数据类型 , 转换新的数据类型会产生新的数组
```python
arr = np.array([1 , 2 , 3 , 4 , 5])
print(arr.dtype)
float_arr = arr.astype(np.float64)
print(float_arr.dtype)
# int32
# float64
```

### 2.数组算术
```python
arr = np.array([1 , 2 , 3 , 4 , 5])
print(arr * arr)
print(arr - arr)
print(1 / arr)
print(arr ** 0.5)

#[ 1  4  9 16 25]
#[0 0 0 0 0]
#[1.         0.5        0.33333333 0.25       0.2       ]
#[1.         1.41421356 1.73205081 2.         2.23606798]
```


### 得到数组维度
```python
arr = np.array([1 , 2 , 3 , 4 , 5])
print(arr.ndim)
# 1
```



### 3.基础索引与切片0-2全部替换
```python
arr = np.array([1 , 2 , 3 , 4 , 5])
arr[:3] = 12
print(arr)
# [12 12 12  4  5]
```


### 当我改变arr_slice，变化也会体现在原数组上
```python

arr_slice = arr[:3]
arr_slice[1] = 12345
print(arr)
# [   12 12345    12     4     5]
```


### 如果你需要拷贝切片的话，显式定义
```python
arr[:3].copy()
```



### 对多维数组的切片
```python
arr2d = np.array([
    [1 , 2 , 3] ,
    [4 , 5 , 6] ,
    [7 , 8 , 9]
])
print(arr2d[:2])
print(arr2d[:3 , 1:])

# [[1 2 3]
# [4 5 6]]

# [[2 3]
#  [5 6]
#  [8 9]]
```



### 4.布尔索引
### 7行4列的随机数组
```python
data = np.random.randn(7 , 4)
```



### 5.数组转置和换轴：
### 重新将数组转换成对应多少行多少列
```python
arr3 = np.arange(15).reshape(3 , 5)
新数组的shape属性应该要与原来数组的一致，即新数组元素数量与原数组元素数量要相等。一个参数为-1时，那么reshape函数会根据另一个参数的维度计算出数组的另外一个shape属性值。
reshape(-1) 将数组碾平成一维
reshape()
print(arr3)
print(arr3.T)
[[ 0  1  2  3  4]
 [ 5  6  7  8  9]
 [10 11 12 13 14]]
[[ 0  5 10]
 [ 1  6 11]
 [ 2  7 12]
 [ 3  8 13]
 [ 4  9 14]]
```



### 6.数组内积
```python
print(np.dot(arr3.T , arr3))
[[125 140 155 170 185]
 [140 158 176 194 212]
 [155 176 197 218 239]
 [170 194 218 242 266]
 [185 212 239 266 293]]
```



### 7.重新组成形状多维多维数字相乘的array的size
```python
arr4 = np.arange(16).reshape((2 , 2 , 4))
```


### 展平数组
```python
print(arr4.reshape(-1))
# [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]
```


### 原来顺序是0，1，2，将x[0][1]的元素 换成 x[1][0]得元素  第一个括号为0轴，第二个括号为1轴
```python
arr4.transpose((1 , 0 , 2))
print(arr4)
 [[[ 0  1  2  3]
   [ 4  5  6  7]],
  [[ 8  9 10 11]
   [12 13 14 15]]]
```



### 8.数组进行面向数组编程
```python
points = np.arange(-5 , 5 , 0.01)
```


### 将两个一维数组的所有（x,y）对形成二维矩阵
```python
xs , ys = np.meshgrid(points , points)

import matplotlib.pyplot as plt

z = np.sqrt(xs ** 2 + ys ** 2)
plt.imshow(z , cmap=plt.cm.gray)
plt.colorbar()
plt.title("image plot of $\sqrt{x^2 + y^2}$ for a grid of values")

```



### 9.将条件逻辑作为数组操作
```python
xarr = np.array([1.1 , 1.2 , 1.3 , 1.4 , 1.5])
yarr = np.array([2.1 , 2.2 , 2.3 , 2.4 , 2.5])
cond = np.array([True , False , True , True , False])
```



### cond数组里为true的用xarr对应值替换，false用yarr对应值替换
```python
result = np.where(cond , xarr , yarr)
print(result)
# [1.1 2.2 1.3 1.4 2.5]
```



### 同时标量也可以
```python
arr5 = np.random.randn(4 , 4)
print(np.where(arr5 > 0 , 2 , -2)) 
[[-2  2  2 -2]
 [-2  2 -2  2]
 [-2 -2  2  2]
 [ 2 -2 -2 -2]]
```

### 10。数学和统计方法
### 正态分布的随机数
```python
arr7 = np.random.randn(5 , 4)
```


### 对二维数组的列求平均
```python
arr7.mean(1)
```


### 对二维数组的行求平均
```python
arr7.mean(0)
```


### 对二维数组进行累加axis=0为对列
### 对二维数组进行累乘axis=0为对列
```python
arr7.cumsum(0)
arr7.cumprod(0)
```


### std,var 标准差和方差
### argmin，argmax最大，最小值的位置

### 11.唯一值与其他集合逻辑
```python
names = np.array(['Bob', 'Job', 'Will', 'Bob', 'Joe', 'Joe'])
np.unique(names)

x = np.array([1, 2, 3, 4, 5, 6])
y = np.array([1, 5, 2, 4, 5, 1])
```


### 12.计算x和y交集，并排序
```python
print(np.intersect1d(x, y))
# [1 2 4 5]
```


### 13.计算x和y并集，并排序
```python
print(np.union1d(x, y))
# [1 2 3 4 5 6 7]
```


### 14.计算x中的元素是否包含在y中，返回一个布尔值数组
```python
print(np.in1d(x, y))
# [ True  True False  True  True False]
```


### 15.差集，在x中但不在y中的x的元素
```python
print(np.setdiff1d(x, y))
 # [3 6]
```


### 16.异或集，在x或y中，但不属于x，y交集得元素
```python
print(np.setdiff1d(x, y))

x1 = np.array([[1., 2., 3.],
               [4., 5., 6.]])
y1 = np.array([[6., 23.],
               [-1, 7],
               [8, 9]])

# [3 6]
```


### 17. 2x3 3x2 矩阵相乘
```python
x1.dot(y1)
arr8: ndarray = np.array([[('a', 1), ('b', 2)], [('c', 3), ('d', 4)]])
arr8.astype(object)
print(arr8.reshape(-1))
# ['a' '1' 'b' '2' 'c' '3' 'd' '4']
```



### 18.矩阵运算
```python
import numpy.linalg as la
X = np.random.randn(5, 5)
mat = X.T.dot(X)
```



### 计算矩阵的逆矩阵
```python
import numpy.linalg as la
print(la.inv(mat))
[[ 10.65229604   3.8663431   18.94274042 -12.49363841   3.96226638]
 [  3.8663431    1.59176822   7.09032292  -4.7652948    1.45282185]
 [ 18.94274042   7.09032292  34.32031827 -22.7693024    7.23087585]
 [-12.49363841  -4.7652948  -22.7693024   15.48411727  -4.73110623]
 [  3.96226638   1.45282185   7.23087585  -4.73110623   1.82792415]]
```


### 计算QR分解
```python
import numpy.linalg as la
q , r = la.qr(mat)
print(q)
print(r)
[[-0.7497835   0.25710162 -0.45501    -0.02908538  0.40477575]
 [-0.25973429 -0.9430599   0.01793438  0.14431535  0.14841684]
 [ 0.57999007 -0.06181348 -0.3284755  -0.07894799  0.73868916]
 [ 0.12720408 -0.19232893 -0.72003395 -0.44134219 -0.48331861]
 [-0.13339208 -0.0610365   0.407798   -0.88165266  0.1867364 ]]

[[-8.17574597 -5.74953553  8.01170206  2.52656228 -2.93450159]
 [ 0.         -8.50786276  0.7267363  -1.83855059 -0.90482186]
 [ 0.          0.         -2.36993784 -2.86285054  2.18831525]
 [ 0.          0.          0.         -0.84080649 -2.65853344]
 [ 0.          0.          0.          0.          0.10215763]]
```


### 计算奇异值分解
```python
import numpy.linalg as la
print(la.svd(mat))
(array([[-0.52024337,  0.33862592, -0.53764056, -0.39923736,  0.40771495],
       [-0.58631351, -0.76069867,  0.03291251,  0.23052946,  0.15279705],
       [ 0.55444988, -0.3360346 , -0.05515777, -0.17981191,  0.73776106],
       [ 0.14219338, -0.43027412, -0.26620814, -0.69411327, -0.49191993],
       [-0.24072738,  0.0928168 ,  0.79746489, -0.52281942,  0.15538655]]), array([14.36576221,  7.6856506 ,  3.38100427,  2.38823269,  0.01588254]), array([[-0.52024337, -0.58631351,  0.55444988,  0.14219338, -0.24072738],
       [ 0.33862592, -0.76069867, -0.3360346 , -0.43027412,  0.0928168 ],
       [-0.53764056,  0.03291251, -0.05515777, -0.26620814,  0.79746489],
       [-0.39923736,  0.23052946, -0.17981191, -0.69411327, -0.52281942],
       [ 0.40771495,  0.15279705,  0.73776106, -0.49191993,  0.15538655]]))
```



### 计算对角元素和

```python
import numpy.linalg as la
print(mat.trace())
27.836532318548905
```


### 计算方阵的特征值和特征向量
```python
print(la.eig(mat))
(array([14.36576221,  7.6856506 ,  0.01588254,  3.38100427,  2.38823269]), array([[-0.52024337, -0.33862592, -0.40771495, -0.53764056,  0.39923736],
       [-0.58631351,  0.76069867, -0.15279705,  0.03291251, -0.23052946],
       [ 0.55444988,  0.3360346 , -0.73776106, -0.05515777,  0.17981191],
       [ 0.14219338,  0.43027412,  0.49191993, -0.26620814,  0.69411327],
       [-0.24072738, -0.0928168 , -0.15538655,  0.79746489,  0.52281942]]))
```


### 计算矩阵的行列式
```python
print(la.det(mat))
14.15962313629787
```


### 求解x的线性系统Ax = b，其中A是方阵
```python
print(la.solve(mat, mat))
[[ 1.00000000e+00  1.44889512e-16 -1.27370418e-16 -1.20763716e-16
   0.00000000e+00]
 [ 6.29747181e-15  1.00000000e+00 -5.05729459e-17 -5.55404781e-17
   0.00000000e+00]
 [ 3.04825660e-14  1.60438858e-16  1.00000000e+00 -2.27816571e-16
   0.00000000e+00]
 [-2.02232030e-14 -1.13780483e-16  2.27560967e-16  1.00000000e+00
   0.00000000e+00]
 [ 6.42230789e-15  0.00000000e+00  0.00000000e+00  0.00000000e+00
   1.00000000e+00]]
```


### 现在需要将矩阵中bai所有的列表长度对du齐到最长的列表的长zhi度5，末尾全部dao用0填充
```python
va = [[1],
      [1, 2],
      [1, 2, 3],
      [1, 2, 3, 4],
      [1, 2, 3, 4, 5],
      [3, 4, 5],
      [2, 3, 4, 5]]
max_len = max(len(l) for l in va)
new_matrix = list(map(lambda l: l + [0] * (max_len - len(l)), va))
print(new_matrix)
[[1, 0, 0, 0, 0], [1, 2, 0, 0, 0], [1, 2, 3, 0, 0], [1, 2, 3, 4, 0], [1, 2, 3, 4, 5], [3, 4, 5, 0, 0], [2, 3, 4, 5, 0]]
```

