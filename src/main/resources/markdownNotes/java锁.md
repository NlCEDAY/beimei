## CAS----compare and swap

线程先读，然后比较得到值在栈中和c



####  乐观锁

-  **乐观锁：**假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁不能解决脏读的问题。




#### 悲观锁

-   **悲观锁：**指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态

### 共享锁

#### 重量级锁--ok

#### 轻量级锁--ok

#### 自旋锁--ok

#### 独占锁

#### 偏向锁--ok

#### 分段锁

#### 读锁

#### 写锁

#### 公平锁

#### 非公平锁

#### 同步锁--ok

#### 

jdk1.0时syschronized为重量级锁，申请资源必须通过内核态，产生系统调用

#### **CAS：**compare and swap  -----无锁（无重量锁）/自旋锁

**第一步：**

读当前值E（从内存拿到线程里）---->计算结果V------>准备把值写回内存时比较E值有没有发生改变，改变了说明其他线程修改过，cas会继续读这个改过的值再次尝试计算结果，再写回主存，再判断有没有改过，。。。。产生自旋，也就是有可能死循环。

相同的话也有可能被其他线程改过，不过改的值刚好没变，这就是造成ABA问题。解决办法就是加一个版本号就行了，就专门的类



AtomicInteger 类    内部自增调用了汇编的cmpxchg的非原子cas操作（这步就是上面的操作）---多核cpu会加lock指令，变成lock cmpxchg 指令

new出来的对象布局：普通对象，对象头里有8个字节的markword， 有一个class pointer指针，指向属于哪个class类型的,xxx.class,还有对象的成员变量,

还有padding，对齐，让对象内存按8个字节对齐，被8整除

**PS：上锁是改了markword，里面存了锁信息，GC信息，hashcode**

**syschronized锁升级得完整过程：**

​						**无锁——>偏向锁——>轻量级锁——>重量级锁**

**一：无锁状态：**

对象得内存布局：

| 锁状态 | 26位   | 31位     | 3位    | 4位      | 1bit | 2bit |
| ------ | ------ | -------- | ------ | -------- | ---- | ---- |
| 无锁态 | unused | hashcode | unamed | 分代年龄 | 0    | 0  1 |

当资源数上升后，锁升级

**二：偏向锁状态：**

**偏向锁：**对第一个线程进行偏向，它不需要申请，可以直接使用资源，jvm加锁的方法，stringbuffer等等在被调用时，实际上只有一个线程在运行，所以才会产生了偏向锁这种东西。

对象得内存布局：

| 锁状态 | 54位         | 2位   | 1位    | 4位      | 1bit | 2bit |
| ------ | ------------ | ----- | ------ | -------- | ---- | ---- |
| 偏向锁 | 当前线程指针 | Epoch | unused | 分代年龄 | 1    | 0  1 |

一般再4s钟之后才会启动偏向锁。因为，当jvm刚运行的时候，里面有很多syn的方法，如果还是由偏向锁再到自旋锁，这样会消耗大量资源。所以jvm既然知道是多线程，所以直接跳过了偏向锁，转变为自旋锁

当资源继续变多后。锁继续升级。

**三：轻量级锁---自旋锁状态：**

对象得内存布局：

| 锁状态 | 62位                         | 2bit |
| ------ | ---------------------------- | ---- |
| 自旋锁 | 指向线程栈中lockRecord的指针 | 0  0 |

当资源竞争变多时，我们将其升级为**轻量级锁----CAS锁**，多个资源进行争抢，都把值读取然后去修改并加上自己的id号，谁先改完往回放贴上id号，这个锁就给谁，剩下来只能在外面自旋，不断改值，再去比较，看看id号有没有被撤销，没又得话继续自旋。

再自己的线程栈里生成lockrecord，当谁能将lockrecord得指针值写到这对象得对象头里，就算抢到锁了。lockrecord作用：记录上一个状态偏向锁得值。



但是自旋会消耗cpu资源，非常多得资源进行争抢时，只有一个资源能拿到，其他都在空自旋浪费资源，判断方式（1.6之前自旋得次数或者等待得线程超过cpu核数得二分之一，1.6之后就变成自适应，jvm自己优化）此时**升级为重量级锁**

**三：重量级锁状态：**

对象得内存布局：

| 锁状态   | 62位                       | 2bit |
| -------- | -------------------------- | ---- |
| 重量级锁 | 指向互斥量（重量级）的指针 | 1  0 |

重量级锁向内核态申请资源，当一个拿到锁后，剩下来得会进入一个等待队列，只有到你的时候，你才能运行，这样不会消耗cpu资源，但是会等的很慢。 





64位的markword

![image-20200526002826988](C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200526002826988.png)







可重入：可嵌套syschronized锁





