## 数据仓库--高级维度建模方法：

### 维度整合：

#### 整合的原因：

- 应用在**编码，命名习惯，度量单位不同**系统会存在较大差异，如0，1和F，M。
- 应用**出于性能和扩展性的考虑，不同的系统用的是不同类型的数据库存储**

> 所以数据由面向应用的操作型环境进入面向主题的数据仓库后，需要**数据集成**。

#### 成为数据仓库前过渡成面向主题的整合方式：

- `命名规范的统一`

  > **表名，字段名**统一

- `字段类型的统一`

  > **相同相似字段得字段类型**统一

- `公共代码及代码值得统一`

  > **公共代码及标志性字段得数据类型，命名方式**得统一

- `业务含义相同得表得统一`

  > 高内聚，低耦合，将业务关系大，源系统影响差异小的表进行整合，将业务关系小，源系统影响差异大的表分而置之。

  - 采用**主从表的设计方式** ：

    > 将多张表都有的字段放在主表，从属信息分别放在各自的从表，对于主表主键，采用复合主键

  - 直接合并：

    > **共有信息和个性信息**都放在同一张表中，如果表字段重合度较低，会出现大量空值，谨慎选择。

  - 不合并：

    > 因为源表的表结构及主键等差异很大，不合并。

#### 成为数据仓库后维度表的整合方式：

> 维度表内容的整合与上述方式相同，下面列表级别的整合

- `垂直整合`

  > **不同的表来自相同的数据集**，在会员相关信息这个数据集里，源系统里可能有多种会员表（会员基础信息表，会员扩展信息表，会员等级信息表），我们需要将多张表整合至会员维度属性。

- `水平整合`

  > **不用的表来自不同的数据集**，存在交叉或者不存在交叉，面对采集的会员数据，可能来自淘宝会员，支付宝会员等等，需要将所有的会员整合到一起，我们**将来源表的各子集的自然键作为联合主键的方式，并在物理实现时将来源字段作为分区字段**。

### 维度拆分：

#### 水平拆分：

>  面对各个行业，大类可以进行水平类别细分

`方案一：将不同分类实例化成不同维度，主维度保存公共属性`--类似雪花模型的味道

`方案二：维度单一维度，包含所有可能的属性`--这就是不拆了，类似星型模型

选取上述两种方案的原则和依据：

##### 三个原则：

- `扩展性：`

  > 当业务，系统逻辑变化时，通过较少的成本快速扩展模型，保持核心模型的相对稳定性

- `效能：`

  > 在性能和成本方面取得平衡，牺牲一定存储成本，达到性能和逻辑的优化

- `易用性：`

  > 模型可理解性高，访问复杂度低。

##### 两个依据：

- `根据维度的不同分类的属性差异情况`

  > 如果除去公共属性外，某些不同分类的都拥有自己的特殊属性，建议拆分，这样保证核心维度的稳定性，也保证子维度的扩展性。

- `根据业务的关联程度`

  > 也就是即使可能两个业务相似度都可以归属化为一个维度，1688商品和淘系商品，但是两个部门的互相调用数据的情况几乎没有，业务人员都只对自己的DM层进行统计分析，尽量拆分，这样保证你变更了，我不需要更新的需求。

#### 垂直拆分：

`方案一：将稳定，产出时间早，热度高（使用频繁）的属性作为主维表，将变化快，产出时间晚，热度低作为从维表`

> ps：对于变化较快的从维表，也需要对主维度表进行缓慢变化的处理（拉链表）

### 维度变化的解决方案：

#### 缓慢变化维：

> 面对的是时间的流逝，维度的属性会发生缓慢的变化

面对**是否保存历史数据变化**，我们提供了三种解决方法：

1. `重写维度值--不保留历史数据`

   > 直接overwrite

2. `插入新的维度行`

   > 做增量，采用历史拉链存储

   **用法** ：维护了一个历史数据表和一个更新表，使用join操作关联

   **优点**：占用磁盘适中，可以查看最新数据也可以查看历史数据

   **缺点**：效率相对较低

   ![image-20200914085637818](C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200914085637818.png)

   **第一步**：每天更新消息将更新表所有数据插入到拉链表中，将起始日期设置为今天，截至日期设置为9999-12-31

   将历史表进行leftjoin更新表，如果能够join上，那么就将历史表的截至日期改为昨天，使用overwrite覆盖掉。

   ```sql
   create table if not exists user_his(
   userid string,
   username string,
   userphone string,
   start_date string,
   end_date string,
   )
   stored as textfile
   
   create table if not exists user_update(
   userid string,
   username string,
   userphone string
   )
   stored as textfile
   
   
   insert into table user_his values
   ('1001','zhangsan','22222222','2020-09-01','9999-12-31'),
   ('1002','lisi','2222we22','2020-09-01','9999-12-31'),
   ('1003','wangwu','22ss2222','2020-09-01','9999-12-31')
   
   
   
   insert into table user_update values
   ('1001','zhangsan','111111111')
   ('1002','lisi','1wwww11111')
   
   
   ```

   **第二步**：每天更新user_his,一天更新多次，一天只算最后一条信息

   更细粒度可以把天改成小时

   ```sql
   insert overwrite table user_his
   select * from
   (
   select *
   '2020-09-14' start_date,
   '9999-12-31' end_date
   from user_update
   
   union all
   
   select
   uh.userid,
   uh.username,
   uh.userphone,
   uh.start_date,
   case when uu.userid is not null and uh.end_date = '9999-12-31' then '2020-09-13' else uh.end_date end end_date
   from user_his uh left join user_update uu on uu.userid = uh.userid
   ) t;
   ```

   

3. `添加维度列`

   > 将记录归为一条，添加新旧属性来完成记录的更改







#### 快照维表：

> 自然键：具有业务含义
>
> 代理键：不具有业务含义，用于缓慢变化维
>
> 在阿里实践中，**并不使用代理键处理缓慢变化维**

- 每天保留一份全量快照数据

> 提高效率，开发维护成本低，同时会极大浪费存储

#### 极限存储：

面对历史拉链存储的方式会出现**两个缺点**：

- 对下游用户解释成本高
- 对于start_dt和end_dt做分区，随着时间不断推移，分区数量会极度膨胀

>  极限存储就是来解决拉链表的问题的解决方案

1. `透明化`

   > 在拉链表上一层做一个视图，或者在hive里做一个hook，让下游用户误以为拉链表是全量存储方式，方便他们写代码。

2. `分月做历史拉链表`

   > 用start_dt和end_dt两个字段做分区，每天做拉链表，一年分区数：365x364 / 2（种组合） = 66430 
   >
   > 但是按照每个月月初重新做一次历史拉链表，一年分区数：12x（1+（30+29）/ 2）=5232

但极限存储也有自己的问题：

- 产出效率不高，通常要t+2
- 对变化频率高的数据并不能达到节约成本的效果

所以实际生产时，续作额外处理：

- 做极限存储前有一个**全量存储表**，该表仅保留最近一段时间的全量分区数据，历史数据通过映射的方式关联到极限存储表。使用户对历史拉链表不可见。
- 对部分变化频繁的字段进行过滤，不过滤就对于每个分区做全量数据，退回了历史拉链表

#### 微型维度：

> 极限存储优化的**不变的时区不做全量，如果所有的商品数据都变化，极限存储就退化为拉链存储，与此同时，如果所有数据都不变化**，那么只需要存储一天即可。

之前的垂直拆分可以把经常变化的给拆分，微型维度也可以做到，是将一部分不稳定的属性放置到使用了代理键的新表实现的。实践中并不推荐。

**缺点：**

- 微型维度的局限性
- ETL逻辑复杂
- 破坏了维度的可浏览性

### 特殊维度：

> 下一章再讲

